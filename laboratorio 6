#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <limits>

using namespace std;

// declaración de funciones que se utilizarán en el programa.
void inicializar_matriz_enteros(vector<vector<int>>& matriz, int n);
void imprimir_matriz(const vector<vector<int>>& matriz, int n);
void aplicar_dijkstra(const vector<char>& V, const vector<vector<int>>& M, int n, int origen);
int elegir_vertice(const vector<int>& D, const vector<bool>& visitados, int n);
void imprimir_grafo(const vector<vector<int>>& matriz, const vector<char>& vector, int n);

int main(int argc, char* argv[]) {
    if (argc < 2) {
        cout << "Uso: ./dijkstra archivo_entrada.txt" << endl;
        return -1;
    }

    ifstream archivo(argv[1]);
    if (!archivo.is_open()) {
        cout << "No se pudo abrir el archivo de entrada." << endl;
        return -1;
    }

    // Leer el número de vértices
    int N;
    archivo >> N;

    if (N <= 2) {
        cout << "El número de vértices debe ser mayor a 2." << endl;
        return -1;
    }

    // Crear e inicializar el vector de nodos
    vector<char> V(N);
    for (int i = 0; i < N; ++i) {
        archivo >> V[i];
    }

    // Crear e inicializar la matriz de adyacencia
    vector<vector<int>> M(N, vector<int>(N));
    inicializar_matriz_enteros(M, N);

    // Leer la matriz de adyacencia desde el archivo
    for (int i = 0; i < N; ++i) {
        for (int j = 0; j < N; ++j) {
            archivo >> M[i][j];
        }
    }

    archivo.close();

    imprimir_matriz(M, N);

    // Seleccionar el nodo origen
    char origen;
    cout << "Ingrese el nodo origen: ";
    cin >> origen;

    int indice_origen = -1;
    for (int i = 0; i < N; i++) {
        if (V[i] == origen) {
            indice_origen = i;
            break;
        }
    }

    if (indice_origen == -1) {
        cout << "Vértice origen no válido." << endl;
        return -1;
    }

    // Ejecutar Dijkstra
    aplicar_dijkstra(V, M, N, indice_origen);

    // Generar el archivo de grafo
    imprimir_grafo(M, V, N);

    return 0;
}

// Inicializar la matriz de enteros con -1 (indicando que no hay conexión)
void inicializar_matriz_enteros(vector<vector<int>>& matriz, int n) {
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            matriz[i][j] = -1;
        }
    }
}

// Imprimir la matriz de adyacencia
void imprimir_matriz(const vector<vector<int>>& matriz, int n) {
    cout << "Matriz de adyacencia:" << endl;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            if (matriz[i][j] == -1)
                cout << "Inf "; // Inf para conexiones inexistentes
            else
                cout << matriz[i][j] << " ";
        }
        cout << endl;
    }
}

// Algoritmo de Dijkstra mejorado con seguimiento de caminos
void aplicar_dijkstra(const vector<char>& V, const vector<vector<int>>& M, int n, int origen) {
    vector<int> D(n, numeric_limits<int>::max()); // Distancia mínima
    vector<int> predecesor(n, -1); // Seguimiento de caminos
    vector<bool> visitados(n, false);

    D[origen] = 0;

    for (int i = 0; i < n - 1; i++) {
        int u = elegir_vertice(D, visitados, n);
        if (u == -1) break; // No quedan vértices accesibles

        visitados[u] = true;

        for (int v = 0; v < n; v++) {
            if (!visitados[v] && M[u][v] != -1 && D[u] != numeric_limits<int>::max() && D[u] + M[u][v] < D[v]) {
                D[v] = D[u] + M[u][v];
                predecesor[v] = u;
            }
        }
    }

    cout << "Distancias mínimas desde " << V[origen] << ":" << endl;
    for (int i = 0; i < n; i++) {
        if (D[i] == numeric_limits<int>::max()) {
            cout << "Hasta " << V[i] << ": Inf (no alcanzable)" << endl;
        } else {
            cout << "Hasta " << V[i] << ": " << D[i] << " (camino: " << V[i];
            int p = predecesor[i];
            while (p != -1) {
                cout << " <- " << V[p];
                p = predecesor[p];
            }
            cout << ")" << endl;
        }
    }
}

// Elegir el vértice con la menor distancia no visitado
int elegir_vertice(const vector<int>& D, const vector<bool>& visitados, int n) {
    int min = numeric_limits<int>::max();
    int min_indice = -1;

    for (int i = 0; i < n; i++) {
        if (!visitados[i] && D[i] < min) {
            min = D[i];
            min_indice = i;
        }
    }

    return min_indice;
}

// Generar archivo DOT para graficar el grafo
void imprimir_grafo(const vector<vector<int>>& matriz, const vector<char>& vector, int n) {
    ofstream archivo("grafo.dot");
    archivo << "digraph G {" << endl;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            if (matriz[i][j] != -1 && matriz[i][j] != 0) {
                archivo << vector[i] << " -> " << vector[j] << " [label=\"" << matriz[i][j] << "\"];" << endl;
            }
        }
    }
    archivo << "}" << endl;
    archivo.close();
    cout << "Archivo grafo.dot generado correctamente." << endl;
}
